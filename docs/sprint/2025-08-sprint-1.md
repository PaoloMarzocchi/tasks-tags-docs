# Sprint 1 — TODO (Agisce: PM/Architect)
Periodo: 2025-08-27 → 2025-09-10
Versione SoT target: **1.1.0**

## Obiettivo Sprint
Rendere utilizzabile l’MVP autenticato con CRUD Task/Tag e filtri `q/status/tag`, allineando FE/E/QA ai contratti SoT.

---

## User Stories & Criteri (Gherkin)

### US-001 — Autenticazione utente
**Come** utente
**voglio** autenticarmi
**per** usare l’app in modo sicuro.

#### Criteri
```gherkin
Scenario: Login riuscito
  Given un account valido esistente
  When chiamo POST /auth/login con email e password corrette
  Then ricevo 200 con un token bearer e i dati utente
  And il token consente l’accesso agli endpoint protetti

Scenario: Login fallito
  Given un account valido esistente
  When chiamo POST /auth/login con password errata
  Then ricevo 401

Scenario: Me autenticato
  Given un token valido ottenuto da /auth/login
  When chiamo GET /auth/me con Authorization: Bearer <token>
  Then ricevo 200 con i miei dati utente

Scenario: Logout
  Given un token valido
  When chiamo POST /auth/logout con Authorization: Bearer <token>
  Then ricevo 204
  And successive chiamate a /auth/me con lo stesso token restituiscono 401
```

### US-002 — Gestione Tag
**Come** utente autenticato
**voglio** creare/aggiornare/eliminare Tag
**per** organizzare i miei Task.

```gherkin
Scenario: Creazione Tag
  Given sono autenticato
  When chiamo POST /tags con name e slug validi
  Then ricevo 201 con l’oggetto Tag creato

Scenario: Lettura Tag
  Given Tag esistenti
  When chiamo GET /tags
  Then ricevo 200 con la lista dei Tag

Scenario: Update Tag
  Given un Tag esistente
  When chiamo PATCH /tags/{id} per aggiornare il name
  Then ricevo 200 con il Tag aggiornato

Scenario: Delete Tag
  Given un Tag esistente
  When chiamo DELETE /tags/{id}
  Then ricevo 204
```

### US-003 — Gestione Task
**Come** utente autenticato
**voglio** creare/aggiornare/eliminare Task
**per** gestire la mia attività.

```gherkin
Scenario: Creazione Task con tag
  Given sono autenticato e esiste un Tag con slug "planning"
  When chiamo POST /tasks con title "Setup" e tags ["planning"]
  Then ricevo 201 con Task contenente il TagRef "planning"

Scenario: Aggiornamento stato
  Given un Task esistente con status "todo"
  When chiamo PATCH /tasks/{id} con status "doing"
  Then ricevo 200 e lo status è "doing"

Scenario: Eliminazione Task
  Given un Task esistente
  When chiamo DELETE /tasks/{id}
  Then ricevo 204
```

### US-004 — Filtri Task
**Come** utente autenticato
**voglio** filtrare Task per `q`, `status`, `tag`
**per** trovare rapidamente ciò che mi serve.

```gherkin
Scenario: Filtro per status
  Given esistono Task con status "done" e "todo"
  When chiamo GET /tasks?status=done
  Then ricevo solo Task con status "done"

Scenario: Filtro per tag
  Given esistono Task con tag "planning"
  When chiamo GET /tasks?tag=planning
  Then ricevo solo Task taggati "planning"

Scenario: Filtro full-text
  Given esistono Task con title che contiene "setup"
  When chiamo GET /tasks?q=setup
  Then ricevo solo Task il cui titolo o descrizione contiene "setup"
```

---

## Piano di Lavoro per Area

### Backend (BE)
1. **Auth minimale**
   - Endpoint: `POST /auth/login`, `POST /auth/logout`, `GET /auth/me`
   - Middleware bearer token (JWT o equivalente)
   - Revoca token in logout
2. **CRUD Tag**
   - `/tags` + `/tags/{id}` con validazioni base (`name`, `slug` univoco)
3. **CRUD Task + filtri**
   - `/tasks` + `/tasks/{id}`
   - Filtri `q` (title/description), `status` (enum), `tag` (slug)
4. **Healthcheck**
   - `/health` già in spec

**Deliverable BE**: rotte, controller/handler, validazioni, test di contratto green.

### Frontend (FE)
1. **Sessione**
   - Form login, memorizzazione token, logout
   - Guard sulle route private
2. **Tag**
   - Lista, create/edit/delete, feedback validazioni
3. **Task**
   - Lista, create/edit/delete
   - Assegnazione tag dal form
4. **Filtri**
   - Barre di ricerca + filtri combinati `q/status/tag`

**Deliverable FE**: UI funzionante end-to-end sui contratti 1.1.0.

### QA
1. **Contract testing**
   - Suite contro `docs/api.yaml@1.1.0` (auth incl.)
2. **E2E**
   - Login → CRUD Tag → CRUD Task → Filtri
3. **Errori**
   - 401 senza token
   - 404 su id inesistenti
   - 422 su `parent_slug` sconosciuto
   - 400 su enum `status` non valido

**Deliverable QA**: report test con esiti e tracciabilità a US.

### Data (DB/Schema)
1. **Schema**
   - `users(id, email, password_hash, name?, created_at, updated_at)`
   - `tags(id, name, slug UNIQUE, color?, parent_id NULLABLE, timestamps)`
   - `tasks(id, title, description?, status ENUM, assignee?, due_date?, timestamps)`
   - `task_tags(task_id, tag_id)` con UNIQUE (task_id, tag_id)
2. **Seed**
   - Utente demo (`demo@local`, password: `demo1234`) per QA
   - Tag e Task di esempio

**Deliverable Data**: migrazioni + seed ripetibili in locale/CI.

---

## Assegnazioni & Dipendenze

- **BE**: Auth prima (sblocca QA/FE) → Tag → Task+Filtri
  - Dipende da **Data** (migrazioni pronte)
- **FE**: aspetta `POST /auth/login` per integrare flusso; poi Tag/Task
  - Dipende da **BE**
- **QA**: parte con contract (mock) e completa quando **BE** espone endpoint
  - Dipende da **Docs** e **BE**
- **Data**: primo task dello sprint
  - Sblocca **BE**

---

## Definition of Done (Sprint)
1. SoT allineato a **v1.1.0** (questo PR) — `VERSION`, `docs/api.yaml`, `CHANGELOG`
2. BE espone endpoint conformi e passa **contract test**
3. FE implementa flussi e UI aderenti alla spec
4. QA produce report con E2E verde su US-001..004
5. Demo end-to-end: login → crea Tag → crea Task → filtra task
6. Nessun **schema drift** (CI verde su SoT)

---

## Note operative
- `bearerAuth` è uno schema logico: implementazione (JWT/session store) è a carico del backend.
- Evitare rename breaking su `Task`/`Tag` in Sprint 1; eventuali cambi richiedono ADR + bump major.